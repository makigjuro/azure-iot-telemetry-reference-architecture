# AlertHandler Service

**Status:** ✅ Fully Implemented
**Type:** Worker Service (BackgroundService)
**Architecture:** Hexagonal Architecture + CQRS (Wolverine)
**Purpose:** Hot path alert processing with C2D device commands

## Overview

The AlertHandler service consumes alert messages from Azure Service Bus (generated by Stream Analytics), evaluates alert severity, sends Cloud-to-Device commands to affected devices via IoT Hub, and audits all alerts to PostgreSQL for compliance tracking.

## Architecture

### High-Level Flow

```
Service Bus (alerts queue)
    ↓
ServiceBusConsumerService (Infrastructure Adapter)
    ↓
Wolverine Message Bus (In-Process CQRS)
    ↓
Command Handlers (Application Layer)
    ↓
IoT Hub C2D Commands + PostgreSQL Audit
```

### Hexagonal Architecture

```
┌─────────────────────────────────────────────────┐
│ Host Layer (AlertHandler.Host)                  │
│ - Program.cs (DI, Wolverine, OpenTelemetry)     │
│ - appsettings.json (Configuration)              │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│ Application Layer (Pure Business Logic)         │
│                                                  │
│ Ports (Interfaces):                             │
│ - IServiceBusConsumer                           │
│ - IDeviceCommandSender                          │
│ - IAlertRepository                              │
│                                                  │
│ Commands:                                        │
│ - ProcessAlertCommand                           │
│ - SendDeviceCommandCommand                      │
│ - AuditAlertCommand                             │
│                                                  │
│ Handlers (Wolverine):                           │
│ - ProcessAlertHandler                           │
│ - SendDeviceCommandHandler                      │
│ - AuditAlertHandler                             │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│ Infrastructure Layer (Adapters)                  │
│                                                  │
│ ServiceBusConsumerService:                      │
│ - ServiceBusProcessor with auto-complete        │
│ - Managed identity authentication               │
│ - Graceful shutdown with message draining       │
│                                                  │
│ DeviceCommandSender:                            │
│ - IoT Hub ServiceClient for C2D commands        │
│ - Timeout handling and delivery confirmation    │
│ - Managed identity authentication               │
│                                                  │
│ AlertRepository:                                │
│ - PostgreSQL alert audit logging                │
│ - Idempotency check (duplicate detection)       │
│ - EF Core 9                                     │
└─────────────────────────────────────────────────┘
                      ↓
┌─────────────────────────────────────────────────┐
│ Domain Layer (Shared.Domain)                     │
│ - Alert (Aggregate)                             │
│ - AlertSeverity (Value Object)                  │
│ - Domain Events (AlertTriggeredEvent)           │
└─────────────────────────────────────────────────┘
```

## Processing Pipeline

### 1. Alert Consumption
```csharp
// ServiceBusConsumerService receives alert from Service Bus
ServiceBusReceivedMessage → DeserializeAlert() → Alert
  → Publish ProcessAlertCommand to Wolverine
```

### 2. Alert Processing & Idempotency Check
```csharp
// ProcessAlertHandler
ProcessAlertCommand
  → Check AlertRepository for duplicate (idempotency)
  → If exists: Skip processing (log warning)
  → If new: Evaluate severity
  → If requires immediate action: Return SendDeviceCommandCommand (cascade)
  → Otherwise: Return null (audit only)
```

**Alert Evaluation:**
- **Info/Warning**: Audit only, no device command
- **Error/Critical + Not Acknowledged**: Send C2D command to device

### 3. Device Command Sending
```csharp
// SendDeviceCommandHandler
SendDeviceCommandCommand
  → Build command payload with alert metadata
  → Send via IoT Hub ServiceClient
  → Handle timeout/errors
  → Return AuditAlertCommand with result (cascade)
```

**Command Payload Structure:**
```json
{
  "command": "HandleAlert",
  "payload": {
    "alertId": "guid",
    "severity": "Critical",
    "message": "Temperature exceeded threshold",
    "timestamp": "2025-01-24T15:30:45Z",
    "temperature": 95.5,
    "threshold": 85.0
  },
  "timestamp": "2025-01-24T15:30:46Z"
}
```

### 4. Audit Logging
```csharp
// AuditAlertHandler
AuditAlertCommand
  → Add metadata (commandSent, commandResult, processedAt)
  → Save to PostgreSQL alerts table
```

**PostgreSQL Schema:**
```sql
CREATE TABLE telemetry.alerts (
  alert_id UUID PRIMARY KEY,
  device_id VARCHAR(200) NOT NULL,
  severity VARCHAR(50) NOT NULL,
  message VARCHAR(2000) NOT NULL,
  timestamp TIMESTAMPTZ NOT NULL,
  created_at TIMESTAMPTZ NOT NULL,
  is_acknowledged BOOLEAN NOT NULL DEFAULT FALSE,
  acknowledged_by VARCHAR(200),
  acknowledged_at TIMESTAMPTZ,
  resolution VARCHAR(2000),
  metadata JSONB NOT NULL
);
```

## Project Structure

```
AlertHandler/
├── AlertHandler.Application/
│   ├── Commands/
│   │   ├── ProcessAlertCommand.cs
│   │   ├── SendDeviceCommandCommand.cs
│   │   └── AuditAlertCommand.cs
│   ├── Handlers/
│   │   ├── ProcessAlertHandler.cs
│   │   ├── SendDeviceCommandHandler.cs
│   │   └── AuditAlertHandler.cs
│   └── Ports/
│       ├── IServiceBusConsumer.cs
│       ├── IDeviceCommandSender.cs
│       └── IAlertRepository.cs
├── AlertHandler.Infrastructure/
│   ├── ServiceBus/
│   │   ├── ServiceBusConsumerService.cs
│   │   └── ServiceBusConsumerOptions.cs
│   ├── IoTHub/
│   │   ├── DeviceCommandSender.cs
│   │   └── IoTHubOptions.cs
│   └── Database/
│       └── AlertRepository.cs
└── AlertHandler.Host/
    ├── Program.cs
    ├── appsettings.json
    └── appsettings.Development.json
```

## Configuration

### appsettings.json

```json
{
  "ServiceBus": {
    "FullyQualifiedNamespace": "sb-iot-dev-mg123.servicebus.windows.net",
    "QueueName": "alerts",
    "MaxConcurrentCalls": 10,
    "MaxAutoLockRenewalDurationSeconds": 300
  },
  "IoTHub": {
    "Hostname": "iot-hub-dev-mg123.azure-devices.net",
    "DefaultMessageTtlSeconds": 3600,
    "CommandTimeoutSeconds": 30
  },
  "ConnectionStrings": {
    "PostgreSQL": "Host=localhost;Database=iot_telemetry;Username=iotuser;Password=iotpass123!"
  }
}
```

## Running Locally

### Prerequisites
- .NET 9 SDK
- Azure subscription with deployed infrastructure
- Azure CLI logged in (`az login`)
- PostgreSQL (via docker-compose or Azure)

### Run the Service

```bash
cd src/Services/AlertHandler/AlertHandler.Host

# Restore dependencies
dotnet restore

# Build
dotnet build

# Run (uses managed identity for Azure auth)
dotnet run
```

### Send Test Alert

```bash
# Using Azure CLI to send alert to Service Bus
az servicebus queue send \
  --namespace-name sb-iot-dev-mg123 \
  --name alerts \
  --body '{
    "deviceId": "test-device-001",
    "severity": "Critical",
    "message": "Temperature exceeded 85°C",
    "timestamp": "2025-01-24T15:30:45Z",
    "metadata": {
      "temperature": 95.5,
      "threshold": 85.0
    }
  }'
```

### Verify Processing

```bash
# Check PostgreSQL for audit logs
psql -h localhost -U iotuser -d iot_telemetry -c "SELECT * FROM telemetry.alerts ORDER BY created_at DESC LIMIT 10;"

# Check device received C2D command (via IoT Hub monitoring)
az iot hub monitor-events \
  --hub-name iot-hub-dev-mg123 \
  --device-id test-device-001
```

## Testing

### Unit Tests (Planned)
```bash
cd src/tests/AlertHandler.Application.Tests
dotnet test
```

**Test Coverage:**
- Command handler logic
- Alert severity evaluation
- Idempotency checks
- Command payload generation

### Integration Tests (Planned)
```bash
cd src/tests/AlertHandler.Tests.Integration
dotnet test
```

**Test Coverage:**
- Service Bus consumption (using Azure SDK test utilities)
- IoT Hub C2D command sending
- PostgreSQL audit logging (using Testcontainers)
- End-to-end pipeline

## Deployment

### Docker Build (Planned)
```bash
cd src/Services/AlertHandler
docker build -t alerthandler:latest -f AlertHandler.Host/Dockerfile .
```

### Azure Container Apps
```bash
az containerapp create \
  --name alert-handler \
  --resource-group rg-iot-dev-mg123 \
  --environment <container-apps-env> \
  --image <acr-name>.azurecr.io/alerthandler:latest \
  --managed-identity system \
  --min-replicas 1 \
  --max-replicas 5 \
  --cpu 0.5 \
  --memory 1.0Gi
```

## Observability

### Logging
- **Serilog** structured logging to console
- **Seq** for local development (`http://localhost:5341`)
- **Application Insights** for production telemetry

### Tracing
- **OpenTelemetry** distributed tracing
- Custom spans for each processing stage
- Correlation IDs across services

### Metrics
- **OpenTelemetry Metrics**
  - Alerts processed count
  - C2D command success rate
  - Processing latency (P50, P95, P99)
  - Service Bus queue depth

### Health Checks
- Liveness: Service is running
- Readiness: PostgreSQL connection healthy

## Resilience

### Service Bus
- **Auto-lock Renewal:** Prevents message timeout during processing
- **Dead-Letter Queue:** Failed messages automatically moved after max retry
- **Idempotency:** Duplicate detection via AlertRepository

### IoT Hub
- **Timeout Handling:** 30-second timeout per C2D command
- **Retry Logic:** Transient failures retry with exponential backoff
- **Graceful Degradation:** Alert still audited even if C2D fails

### PostgreSQL
- **Retry Policy:** 3 retries with 30-second max delay
- **Connection Pooling:** EF Core connection management

## Performance

### Throughput
- **Design Target:** 1,000 alerts/minute
- **Concurrent Processing:** 10 messages (configurable)
- **Scalability:** Horizontal scaling via Container Apps

### Latency
- **Alert Processing:** <100ms (P95) excluding C2D command
- **C2D Command Delivery:** <500ms (P95)
- **End-to-End:** <1 second (P95) from Service Bus to PostgreSQL

## Troubleshooting

### Common Issues

**Issue: "Unable to connect to Service Bus"**
- Ensure managed identity has "Azure Service Bus Data Receiver" role
- Check Service Bus namespace and queue name in appsettings.json
- Verify network connectivity

**Issue: "Failed to send C2D command"**
- Ensure managed identity has "IoT Hub Registry Contributor" role
- Verify IoT Hub hostname in appsettings.json
- Check device is registered and connected

**Issue: "PostgreSQL connection failed"**
- Ensure PostgreSQL is running (docker-compose up -d postgres)
- Verify connection string in appsettings.json
- Check database migrations applied

**Issue: "Duplicate alert processing"**
- This is expected behavior - idempotency check will skip duplicates
- Check logs for "already been processed" warning

## Next Steps

1. **Unit Tests** - Add xUnit tests for handlers
2. **Integration Tests** - Add Testcontainers-based integration tests
3. **Dockerfile** - Create optimized multi-stage Dockerfile
4. **CI/CD** - Add GitHub Actions workflow for build/test/deploy
5. **Monitoring** - Add custom Application Insights dashboards
6. **Advanced Alerting** - Add alert suppression and throttling logic

## References

- [Wolverine Documentation](https://wolverine.netlify.app/)
- [Azure Service Bus .NET SDK](https://learn.microsoft.com/azure/service-bus-messaging/service-bus-dotnet-get-started-with-queues)
- [Azure IoT Hub C2D Commands](https://learn.microsoft.com/azure/iot-hub/iot-hub-devguide-messages-c2d)
- [Hexagonal Architecture](https://alistair.cockburn.us/hexagonal-architecture/)
